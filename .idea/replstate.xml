<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1465126902152">{:repl-history {:ide [], :local [&quot;(#(format \&quot;%1s\&quot; %) \&quot;hi\&quot;)&quot; &quot;(map #(format \&quot;%2s\&quot; %) \&quot;hibdddd\&quot;)&quot; &quot;(map #(format \&quot;%2s\&quot; %) [\\a \\b])&quot; &quot;(map #(printf \&quot;%2s\&quot; %) [\\a \\b])&quot; &quot;(map #(printf \&quot;%2s\&quot; %) \&quot;hello\&quot;)&quot; &quot;(map #(printf \&quot;%4s\&quot; %) \&quot;hello\&quot;)&quot; &quot;(map #(printf \&quot;%4s\&quot; %) [2 3 4 22])&quot; &quot;(map #(printf \&quot;%3s\&quot; %) (range 1 27))&quot; &quot;(keys root)&quot; &quot;(type (keys root))&quot; &quot;(if (root :a) \&quot;yes\&quot; \&quot;no\&quot;)&quot; &quot;(if (root :clues) \&quot;yes\&quot; \&quot;no\&quot;)&quot; &quot;(root :encodemap)&quot; &quot;(if )&quot; &quot;(if (root :encodemap) 4 \&quot;yes\&quot; \&quot;no\&quot;)&quot; &quot;(if ((root :encodemap 4) \&quot;yes\&quot; \&quot;no\&quot;))&quot; &quot;(if ((root :encodemap) 4) \&quot;yes\&quot; \&quot;no\&quot;)&quot; &quot;(if ((root :encodemap) 2) \&quot;yes\&quot; \&quot;no\&quot;)&quot; &quot;(def ccnumber 11)&quot; &quot;(count nil)&quot; &quot;(type ans)&quot; &quot;(take 1 ans)&quot; &quot;(count *1)&quot; &quot;(range 0)&quot; &quot;(doseq [n (range 0)])&quot; &quot;s= (printcctable root)&quot; &quot;root&quot; &quot;(def ans (filter\n             all-completed-and-all-good?\n             (tree-seq non-completed-and-all-good? (children-from-best-clue-using :wordcountscore) root)))&quot; &quot;(def ans (filter\n             all-completed-and-all-good?\n             (tree-seq non-completed-and-all-good? (partial children-from-top-clues 1) root)))&quot; &quot;(def ans (tree-seq non-completed-and-all-good? (children-from-best-clue-using :wordcountscore) root))&quot; &quot;(def ccnumber 21)&quot; &quot;(clojure.pprint/pp [[1 2 3] [4 5 6]])&quot; &quot;(clojure.pprint/pprint [[1 2 3] [4 5 6]])&quot; &quot;(def ans (filter\n             (complement non-completed-some-could-be-bad?)\n             (tree-seq non-completed-some-could-be-bad? (children-from-best-clue-using :wordcountscore) root)))&quot; &quot;(def ans (tree-seq non-completed-some-could-be-bad? (children-from-best-clue-using :wordcountscore) root))&quot; &quot;(count ans)&quot; &quot;(def ans (tree-seq non-completed-some-could-be-bad? (partial children-from-best-clue :wordcountscore) root))&quot; &quot;(root :word)&quot; &quot;(root :wordcountscores)&quot; &quot;(root :simplescores)&quot; &quot;(number? 3)&quot; &quot;(root :numinothers)&quot; &quot;(apply number? [])&quot; &quot;(apply number? [3])&quot; &quot;(apply number? [3 4])&quot; &quot;(apply number? [\\a])&quot; &quot;(apply number? [\\a 4])&quot; &quot;(number? [3])&quot; &quot;(defn numinother-score\n  [decodedclue oldnuminother]\n  (if (and (= (count decodedclue) 1) (apply number? decodedclue)) oldnuminother 1) decodedclue oldnuminother)&quot; &quot;(numinother-score [\\a] 5)&quot; &quot;(numinother-score [1] 5)&quot; &quot;(numinother-score [\\a 3] 5)&quot; &quot;(numinother-score [1 2] 5)&quot; &quot;(def ans (tree-seq non-completed-and-all-good? (children-from-best-clue-using :numinothers) root))&quot; &quot;(show-at-most-n ans 5)&quot; &quot;(show-at-most-n ans 50)&quot; &quot;(def ans (filter\n             completeall-good?\n             (tree-seq non-completed-and-all-good? (children-from-best-clue-using :numinothers) root)))&quot; &quot;(def ans (filter\n             all-completed-and-all-good?\n             (tree-seq non-completed-and-all-good? (children-from-best-clue-using :simplescores) root)))&quot; &quot;(show-at-most-n ans 150)&quot; &quot;(show-from-root (nth ans 130))&quot; &quot;(def ans (filter\n             all-good?\n             (tree-seq non-completed-and-all-good? (children-from-best-clue-using :numinothers) root)))&quot; &quot;(def root (make-root root {1 \\n 4 \\s 13 \\t 16 \\o}))&quot; &quot;(def ans (filter\n             all-completed?\n             (tree-seq non-completed-and-all-good? (children-from-best-clue-using :numinothers) root)))&quot; &quot;(def ans (filter\n             all-completed-and-all-good?\n             (tree-seq non-completed-and-all-good? (children-from-best-clue-using :numinothers) root)))&quot; &quot;(defn apply-bitmask [s bitmask]\n  (for [[item bit] (map vector s bitmask)\n        :when (= bit 1)]\n    item))&quot; &quot;(apply-bitmask [1 23 4 5 3] [0 1 1 0 1])&quot; &quot;(map vector [1 2 3 4 5] [0 1 1 0 1])&quot; &quot;(def root (make-root (get-cc ccnumber)))&quot; &quot;(def ans (filter\n             all-completed-or-not-completable?\n             (tree-seq non-completed-some-could-be-bad? (children-from-best-clue-using :simplescores) root)))&quot; &quot;(show-at-most-n ans 1)&quot; &quot;(show-at-most-n ans 3)&quot; &quot;(show-at-most-n ans 2)&quot; &quot;(defn f [a :a b :b] (println a b))&quot; &quot;(defn f {a :a b :b} (println a b))&quot; &quot;(defn f [{a :a b :b}] (println a b))&quot; &quot;(f {:a 4})&quot; &quot;(f {:b 4})&quot; &quot;(f {:b 4 :a \&quot;aaa\&quot; :c 333})&quot; &quot;(if nil \&quot;t\&quot; \&quot;f\&quot;)&quot; &quot;(if true \&quot;t\&quot; \&quot;f\&quot;)&quot; &quot;(if (not nil) \&quot;t\&quot; \&quot;f\&quot;)&quot; &quot;(def root (make-example-for-work \&quot;abcd efgh ijkl mnop aeim bfjn cgko dhlp\&quot;))&quot; &quot;(printinfoencoding 0 root)&quot; &quot;(def root (make-root {:ccinfo root :rootmap {1 \\n 4 \\s 13 \\t 16 \\o}}))&quot; &quot;(printcctable root)&quot; &quot;(def root (make-example-for-work \&quot;abc def ghi adg beh cfi\&quot;))&quot; &quot;(def ans (filter\n             all-completed-and-all-good?\n             (tree-seq non-completed-and-all-good? (children-from-best-clue-using :wordcountscores) root)))&quot; &quot;(def ccnumber 43)&quot; &quot;(def ccnumber 33)&quot; &quot;(def root (make-root {:ccinfo (get-cc ccnumber) :rootmap {}}))&quot; &quot;(def root (make-root {:ccinfo (get-cc ccnumber)}))&quot; &quot;(show-at-most-n ans 10)&quot; &quot;(def root (make-root {:ccinfo (get-cc ccnumber) :singleclues true}))&quot; &quot;(def root (make-root {:ccinfo (get-cc ccnumber) :singleclues false}))&quot; &quot;(def root (make-root {:ccinfo (get-cc ccnumber) :addsingleclues false}))&quot; &quot;(def root (make-root {:ccinfo (get-cc ccnumber) :addsingleletters false}))&quot; &quot;(def root (make-root {:ccinfo (get-cc ccnumber) :addsingleletters }))&quot; &quot;(def root (make-root {:ccinfo (get-cc ccnumber) :addsingleletters true}))&quot; &quot;(def ans (filter\n             (complement non-completed-some-could-be-bad?)\n             (tree-seq non-completed-some-could-be-bad? (children-from-best-clue-using :wordcountscores) root)))&quot; &quot;(show-from-root (nth ans 0))&quot; &quot;(doc make-root)&quot;], :remote []}}</component>
</project>