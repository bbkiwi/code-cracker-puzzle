<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1462096463576">{:repl-history {:ide [], :local [&quot;(letpat \&quot;\&quot;)&quot; &quot;(letpat \&quot;abc\&quot;)&quot; &quot;(defn pat-for\n  \&quot;Gives pattern for letter n 1...9\&quot;\n  [n letuse]\n  (cond\n    (= n 1) (letpat letuse)\n    :else (re-pattern (str \&quot;(?!\\\\\&quot; (clojure.string/join \&quot;|\\\\\&quot; (range 1 n)) \&quot;)\&quot; (letpat letuse)))))&quot; &quot;(defn letpat\n  [letuse]\n  (cond\n    (= letuse \&quot;\&quot;) #\&quot;(\\w)\&quot;\n    :else (re-pattern (str \&quot;([\&quot; letuse \&quot;])\&quot;))))&quot; &quot;(pat-for 3 \&quot;abc\&quot;)&quot; &quot;(pat-for 1 \&quot;\&quot;)&quot; &quot;(contains? {1 2 3} 2)&quot; &quot;(contains? #{1 2 3} 2)&quot; &quot;(contains? #{1 2 43} 43)&quot; &quot;(contains? #{1 2 43} 42)&quot; &quot;(contains? #{1 2 43} 2)&quot; &quot;(contains? #{1 2 43} 1)&quot; &quot;(contains? (range 1 10) 1)&quot; &quot;(range 1 10)&quot; &quot;(contains? (set (range 1 10)) 10)&quot; &quot;(contains? (set (range 1 10)) 9)&quot; &quot;(contains? (set (range 1 10)) 0)&quot; &quot;(contains? (set (range 1 10)) 1)&quot; &quot;(pat-for 3 \&quot;\&quot;)&quot; &quot;(defn pat-for-new\n  \&quot;Gives pattern for letter n 1...9\&quot;\n  [n letuse]\n  (cond\n    (= n 1) (letpat letuse)\n    :else (re-pattern (str \&quot;(?!\\\\\&quot; (clojure.string/join \&quot;|\\\\\&quot; (range 1 n)) \&quot;)\&quot; (letpat letuse)))))&quot; &quot;(defn pat-for-old\n  \&quot;Gives pattern for subsequent use of letter n 1...8\&quot;\n  [n letuse]\n  (re-pattern (str \&quot;\\\\\&quot; (inc n))))&quot; &quot;(pat-for-old 4 4)&quot; &quot;(defn pat-for-old\n  \&quot;Gives pattern for subsequent use of letter n 1...8\&quot;\n  [n &amp; letuse]\n  (re-pattern (str \&quot;\\\\\&quot; (inc n))))&quot; &quot;(pat-for-old 4)&quot; &quot;(pat-for-old 4 \&quot;adsf\&quot;)&quot; &quot;(contains? \&quot;abc\&quot; \\a)&quot; &quot;(contains? (set \&quot;abc\&quot;) \\a )&quot; &quot;(contains? (set \&quot;abc\&quot;) \\d )&quot; &quot;(contains? (set \&quot;abc\&quot;) \\dd )&quot; &quot;(contains? (set \&quot;abc\&quot;) \\d)&quot; &quot;(contains? (set \&quot;abc08\&quot;) 0)&quot; &quot;(contains? (set \&quot;abc08\&quot;) \\0)&quot; &quot;(char 0)&quot; &quot;(nth \&quot;abc\&quot; 0)&quot; &quot;(nth \&quot;abc\&quot; 1)&quot; &quot;(nth \&quot;abc\&quot; 10)&quot; &quot;(first \&quot;abd\&quot;)&quot; &quot;(rest \&quot;abd\&quot;)&quot; &quot;(nth \&quot;abd\&quot; 0)&quot; &quot;(clojurs.string/first \&quot;abd\&quot;)&quot; &quot;(str (first \&quot;abcd\&quot;))&quot; &quot;(str (rest \&quot;abcd\&quot;))&quot; &quot;(rest \&quot;abc\&quot;)&quot; &quot;(clojure.string/join \&quot;\&quot; (rest \&quot;abcd\&quot;))&quot; &quot;(first \&quot;0abd\&quot;)&quot; &quot;(set \&quot;1234\&quot;)&quot; &quot;(int \\1)&quot; &quot;(format \\1)&quot; &quot;(format %i \\1)&quot; &quot;(int \&quot;1\&quot;)&quot; &quot;(eval \&quot;1\&quot;)&quot; &quot;(eval \n  1)&quot; &quot;(eval \n  \\1)&quot; &quot;(defn char-&gt;num\n  [ch]\n  (- (int ch) (int \\0)))&quot; &quot;(char-&gt;num \\1)&quot; &quot;(char-&gt;num \\2)&quot; &quot;(char-&gt;num \\0)&quot; &quot;(defn pat-for-sym\n  \&quot;\&quot;\n  [char-from-pat letuse]\n  (cond\n    (= char-from-pat \\0) (str \&quot;[\&quot; letuse \&quot;]\&quot;)\n    (contains? (set \&quot;123456789\&quot;) char-from-pat)(pat-for-new (char-&gt;num char-from-pat) letuse )))&quot; &quot;(defn pat-for-sym\n  \&quot;\&quot;\n  [char-from-pat letuse cleaned-letuse]\n  (cond\n    (= char-from-pat \\0) (str \&quot;[\&quot; letuse \&quot;]\&quot;)\n    (contains? (set \&quot;123456789\&quot;) char-from-pat)(pat-for-new (char-&gt;num char-from-pat) cleaned-letuse )\n    :else (str char-from-pat)))&quot; &quot;(defn code-cracker-to-regexpat\n  \&quot;Converts code cracker pattern to regex. Assume letters assigned sequentially from 1 to 8\n  0 is a free letter\&quot;\n  [code-cracker-pat letuse cleaned-letuse]\n  (if (empty? code-cracker-pat) \&quot;\&quot;\n   (clojure.string/join \&quot;\&quot; (str\n                             (pat-for-sym (first code-cracker-pat) letuse cleaned-letuse)\n                             (code-cracker-to-regexpat (str (rest code-cracker-pat)) letuse cleaned-letuse)))))&quot; &quot;(code-cracker-to-regexpat \&quot;123ab\&quot; \&quot;abcd\&quot; \&quot;cd\&quot;)&quot; &quot;(empty? \&quot;\&quot;)&quot; &quot;(empty? \&quot;a\&quot;)&quot; &quot;(first \&quot;abc\&quot;)&quot; &quot;(pat-for-new 1 \&quot;abcd\&quot; \&quot;cd\&quot;)&quot; &quot;(pat-for-new 1 \&quot;abcd\&quot;)&quot; &quot;(pat-for-new 2 \&quot;abcd\&quot;)&quot; &quot;(pat-for-sym \\a \&quot;abcd\&quot; \&quot;cd\&quot;)&quot; &quot;(pat-for-sym \\1 \&quot;abcd\&quot; \&quot;cd\&quot;)&quot; &quot;(pat-for-sym \\0 \&quot;abcd\&quot; \&quot;cd\&quot;)&quot; &quot;(pat-for-sym \\4 \&quot;abcd\&quot; \&quot;cd\&quot;)&quot; &quot;(str \&quot;ab\&quot; )&quot; &quot;(str \&quot;ab\&quot; \&quot;adf\&quot;)&quot; &quot;(defn code-cracker-to-regexpat\n  \&quot;Converts code cracker pattern to regex. Assume letters assigned sequentially from 1 to 8\n  0 is a free letter\&quot;\n  [code-cracker-pat letuse cleaned-letuse]\n  (if (empty? code-cracker-pat) \&quot;\&quot;\n   (str\n                             (pat-for-sym (first code-cracker-pat) letuse cleaned-letuse)\n                             (code-cracker-to-regexpat (str (rest code-cracker-pat)) letuse cleaned-letuse))))&quot; &quot;(defn code-cracker-to-regexpat\n  \&quot;Converts code cracker pattern to regex. Assume letters assigned sequentially from 1 to 8\n  0 is a free letter\&quot;\n  [code-cracker-pat letuse cleaned-letuse]\n  (println code-cracker-pat)\n  (if (empty? code-cracker-pat) \&quot;\&quot;\n   (str\n     (pat-for-sym (first code-cracker-pat) letuse cleaned-letuse)\n     (code-cracker-to-regexpat (str (rest code-cracker-pat)) letuse cleaned-letuse))))&quot; &quot;(code-cracker-to-regexpat \&quot;\&quot; \&quot;abcd\&quot; \&quot;cd\&quot;)&quot; &quot;(code-cracker-to-regexpat \&quot;123\&quot; \&quot;abcd\&quot; \&quot;cd\&quot;)&quot; &quot;(doc if)&quot; &quot;(defn code-cracker-to-regexpat\n  \&quot;Converts code cracker pattern to regex. Assume letters assigned sequentially from 1 to 8\n  0 is a free letter\&quot;\n  [code-cracker-pat letuse cleaned-letuse]\n  (println code-cracker-pat)\n  (if (empty? code-cracker-pat) \&quot;\&quot;\n   (str\n     (pat-for-sym (first code-cracker-pat) letuse cleaned-letuse)\n     #_(code-cracker-to-regexpat (str (rest code-cracker-pat)) letuse cleaned-letuse))))&quot; &quot;(code-cracker-to-regexpat \&quot;1xy\&quot; \&quot;abcd\&quot; \&quot;cd\&quot;)&quot; &quot;(rest \&quot;2xy\&quot;)&quot; &quot;(str (rest \&quot;2xy\&quot;))&quot; &quot;(join \&quot;\&quot; (rest \&quot;2xy\&quot;))&quot; &quot;(clojure.string/join \&quot;\&quot; (rest \&quot;2xy\&quot;))&quot; &quot;(defn code-cracker-to-regexpat\n  \&quot;Converts code cracker pattern to regex. Assume letters assigned sequentially from 1 to 8\n  0 is a free letter\&quot;\n  [code-cracker-pat letuse cleaned-letuse]\n  (println code-cracker-pat)\n  (if (empty? code-cracker-pat) \&quot;\&quot;\n   (str\n     (pat-for-sym (first code-cracker-pat) letuse cleaned-letuse)\n     (code-cracker-to-regexpat (clojure.string/join \&quot;\&quot; (rest code-cracker-pat)) letuse cleaned-letuse))))&quot; &quot;(code-cracker-to-regexpat \&quot;2xy\&quot; \&quot;abcd\&quot; \&quot;cd\&quot;)&quot; &quot;(code-cracker-to-regexpat \&quot;2xy2\&quot; \&quot;abcd\&quot; \&quot;cd\&quot;)&quot; &quot;(defn code-cracker-to-regexpat\n  \&quot;Converts code cracker pattern to regex. Assume letters assigned sequentially from 1 to 8\n  0 is a free letter\&quot;\n  [code-cracker-pat letuse cleaned-letuse]\n  ;(println code-cracker-pat)\n  (if (empty? code-cracker-pat) \&quot;\&quot;\n   (str\n     (pat-for-sym (first code-cracker-pat) letuse cleaned-letuse)\n     (code-cracker-to-regexpat (clojure.string/join \&quot;\&quot; (rest code-cracker-pat)) letuse cleaned-letuse))))&quot; &quot;(code-cracker-to-regexpat \&quot;2xy0\&quot; \&quot;abcd\&quot; \&quot;cd\&quot;)&quot; &quot;(re-pattern (code-cracker-to-regexpat \&quot;2xy0\&quot; \&quot;abcd\&quot; \&quot;cd\&quot;))&quot; &quot;(defn pat-for-sym\n  \&quot;\&quot;\n  [char-from-pat letuse cleaned-letuse]\n  (cond\n    (= char-from-pat \\0) (letpat letuse)\n    ; TODO fix below as should either use pat-for-new or pat-for-old\n    (contains? (set \&quot;123456789\&quot;) char-from-pat)(pat-for-new (char-&gt;num char-from-pat) cleaned-letuse )\n    :else (str char-from-pat)))&quot; &quot;(code-cracker-to-regexpat \&quot;1a2xy0\&quot; \&quot;\&quot; \&quot;cd\&quot;)&quot; &quot;(re-pattern (code-cracker-to-regexpat \&quot;1a2xy0\&quot; \&quot;abcd\&quot; \&quot;cd\&quot;))&quot; &quot;(re-pattern (code-cracker-to-regexpat \&quot;1a2xy0\&quot; \&quot;\&quot; \&quot;cd\&quot;))&quot; &quot;(re-pattern (code-cracker-to-regexpat \&quot;1a2xy0\&quot; \&quot;\&quot; \&quot;\&quot;))&quot; &quot;(findall (re-pattern (code-cracker-to-regexpat \&quot;1a2xy0\&quot; \&quot;\&quot; \&quot;\&quot;)) word-dic)&quot; &quot;(findall (re-pattern (code-cracker-to-regexpat \&quot;1a20\&quot; \&quot;\&quot; \&quot;\&quot;)) word-dic)&quot; &quot;(concat #\&quot; \&quot; #\&quot;ab\&quot;)&quot; &quot;(concat \&quot; \&quot; \&quot;ab\&quot;)&quot; &quot;(clojure.string/join \&quot;\&quot; #\&quot; \&quot; #\&quot;ab\&quot;)&quot; &quot;(clojure.string/join \&quot;\&quot; [#\&quot; \&quot; #\&quot;ab\&quot;])&quot;], :remote []}}</component>
</project>