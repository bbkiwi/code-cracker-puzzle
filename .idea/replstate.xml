<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1462190509666">{:repl-history {:ide [], :local [&quot;\&quot;hello\&quot;&quot; &quot;(array-map 1 2 3 4)&quot; &quot;(val *1)&quot; &quot;(doc val)&quot; &quot;(doc vals)&quot; &quot;(vals [1 2 3 4])&quot; &quot;(vals (array-map 1 2 3 4))&quot; &quot;(doc apply)&quot; &quot;(vals (apply (array-map [1 2 3 4])))&quot; &quot;(vals (apply array-map [1 2 3 4]))&quot; &quot;(doc zipmap)&quot; &quot;(zipmap [1 2 3] \&quot;abc\&quot;)&quot; &quot;(zipmap [1 2 3] \&quot;abcd\&quot;)&quot; &quot;(zipmap [1 2 3 4 5] \&quot;abcd\&quot;)&quot; &quot;(decode1 [1 2 4 3 4 2] \&quot;abc?\&quot;)&quot; &quot;(decode2 [1 2 4 3 4 2] (zipmap [1 2 3 4] \&quot;abc?\&quot;))&quot; &quot;(decode2 [1 2 4 3 4 2] (zipmap [1 2 3] \&quot;abc\&quot;))&quot; &quot;(decode2 [1 2 4 3 4 2 5 3] (zipmap [1 2 3] \&quot;abc\&quot;))&quot; &quot;(filter number? t)&quot; &quot;(set (filter number? t))&quot; &quot;(doc set)&quot; &quot;(doc distinct)&quot; &quot;(def t (decode2 [1 2 4 3 4 2 5 3] (zipmap [1 2 3] \&quot;abc\&quot;)))&quot; &quot;(range 1 2)&quot; &quot;(range 1 3)&quot; &quot;t&quot; &quot;(distinct (filter number? t))&quot; &quot;(def d (distinct (filter number? t)))&quot; &quot;(make-code-cracker-pat t)&quot; &quot;(clojure.string/join \&quot;\&quot; *1)&quot; &quot;(make-code-cracker-pat (decode2 [1 2 4 3 4 2 5 3] (zipmap [1 2 3] \&quot;abc\&quot;)))&quot; &quot;(code-cracker-string-to-regexpat \n  (make-code-cracker-pat (decode2 [1 2 4 3 4 2 5 3] (zipmap [1 2 3] \&quot;abc\&quot;)))\n  \&quot;\&quot;)&quot; &quot;(code-cracker-vec-to-regexpat \n  (make-code-cracker-pat (decode [1 2 4 3 4 2 5 3] (zipmap [1 2 3] \&quot;abc\&quot;)))\n  \&quot;\&quot;)&quot; &quot;(code-cracker-string-to-regexpat \n  (make-code-cracker-pat (decode [1 2 4 3 4 2 5 3] (zipmap [1 2 3] \&quot;abc\&quot;)))\n  \&quot;\&quot;)&quot; &quot;(code-cracker-pat-to-regexpat \n  (make-code-cracker-pat (decode [1 2 4 3 4 2 5 3] (zipmap [1 2 3] \&quot;abc\&quot;)))\n  \&quot;\&quot;)&quot; &quot;(assigned-letters-string-&gt;assigned-letters-map \&quot;abc\&quot;)&quot; &quot;(assigned-letters-string-&gt;assigned-letters-map \&quot;abca\&quot;)&quot; &quot;(filter #(= (val %) \\a) *1)&quot; &quot;(int \\a)&quot; &quot;(filter #(&gt;= (int \\a) (int (val %)) (int \\z) *1))&quot; &quot;(filter #(&gt;=  \\a (val %) \\z) *1)&quot; &quot;(&lt;= \\a \\z)&quot; &quot;(&lt;= (int \\a) (int \\z))&quot; &quot;(&lt;= (int \\b) (int \\a))&quot; &quot;(filter #(&gt;= (int \\a) (int (val %)) (int \\z)) *1)&quot; &quot;(assigned-letters-string-&gt;assigned-letters-map \&quot;abc...z\&quot;)&quot; &quot;(filter #(&lt;= (int \\a) (int (val %)) (int \\z)) *1)&quot; &quot;(doc hash-map)&quot; &quot;{*1}&quot; &quot;(replace {1 \\a 3 \\b} \&quot;....\&quot;)&quot; &quot;(replace {1 \\a 3 \\b} \&quot;..13.\&quot;)&quot; &quot;(replace {1 \\a 3 \\b} [1 2 3 4 5])&quot; &quot;(vals *1)&quot; &quot;(vec *1)&quot; &quot;(assoc {} *1)&quot; &quot;(zipmap (range 1 (inc (count \&quot;abc..d\&quot;))) \&quot;abc..d\&quot;)&quot; &quot;(map identity *1)&quot; &quot;(apply (partial assoc {}) *1)&quot; &quot;(type *1)&quot; &quot;(replace *1 [1 2 3])&quot; &quot;(type {1 \\a 2 \\b})&quot; &quot;(replace {1 \\a 2 \\b} [1 2 3])&quot; &quot;(replace {1 \\a 2 \\b} (range 1 4))&quot; &quot;(replace *1 (range 1 4))&quot; &quot;(def fields [:name :age :color])\n(def values [\&quot;joe\&quot; 32 \&quot;red\&quot;])\n(def record (interleave fields values))&quot; &quot;fields&quot; &quot;values&quot; &quot;record&quot; &quot;(apply hash-map record)&quot; &quot;(flatten +1)&quot; &quot;(flatten *1)&quot; &quot;(apply hash-map *1)&quot; &quot;(def dmap (zipmap (range 1 27) \\.))&quot; &quot;(def dmap (zipmap (range 1 27) \&quot;............................\&quot;))&quot; &quot;dmap&quot; &quot;(def dmap (zipmap (range 1 27) \&quot;'''''''''''''''''''''''''''''''\&quot;))&quot; &quot;(str *1)&quot; &quot;(str '(\\a \\b))&quot; &quot;(clojure.string/join \&quot;\&quot; '(\\a \\b))&quot; &quot;(assigned-letters-string-&gt;assigned-letters-map \&quot;abc....d\&quot;)&quot; &quot;(assigned-letters-map-&gt;assigned-letters-string *1)&quot; &quot;(assigned-letters-string-&gt;assigned-letters-map *1)&quot; &quot;(code-solver [1 2 3 2 1], \&quot;\&quot;)&quot; &quot;(code-solver [1 2 3 2 1], {})&quot; &quot;(make-code-cracker-pat \&quot;12321\&quot;)&quot; &quot;(make-code-cracker-pat [1 2 3 2 1])&quot; &quot;(code-cracker-pat-to-regexpat \&quot;12321\&quot;)&quot; &quot;(code-cracker-pat-to-regexpat (make-code-cracker-pat \&quot;12321\&quot;))&quot; &quot;(code-cracker-pat-to-regexpat (make-code-cracker-pat \&quot;12321\&quot;) \&quot;\&quot;)&quot; &quot;(code-cracker-pat-to-regexpat (make-code-cracker-pat [1 2 3 2 1] \&quot;\&quot;))&quot; &quot;(code-cracker-pat-to-regexpat (make-code-cracker-pat [1 2 3 2 1]) \&quot;\&quot;)&quot; &quot;(first (make-code-cracker-pat \&quot;12321\&quot;))&quot; &quot;(first (make-code-cracker-pat [1 2 3 2 1]))&quot; &quot;(str 1)&quot; &quot;(char 1)&quot; &quot;(clojure.string/join \&quot;\&quot; [1 2 3 4])&quot; &quot;(clojure.string/join \&quot;\&quot; \&quot;1234\&quot;)&quot; &quot;(clojure.string/join \&quot;\&quot; 1)&quot; &quot;(clojure.string/join \&quot;\&quot; \\1)&quot; &quot;(code-solver [1 7 3 7 1], {})&quot; &quot;(zipmap [1 7 3 7 1] \&quot;level\&quot;)&quot;], :remote []}}</component>
</project>