<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1463458195628">{:repl-history {:ide [], :local [&quot;(decode-to-vec (nth (:clues ccc) 2) (:encodemap ccc))&quot; &quot;(decode-to-vec (nth (:clues ccc) 3) (:encodemap ccc))&quot; &quot;(decode-to-vec (nth (:clues ccc) 4) (:encodemap ccc))&quot; &quot;(decode-to-vec (nth (:clues ccc) 5) (:encodemap ccc))&quot; &quot;(map #(decode-to-vec  % (:encodemap ccc)) (:clues ccc))&quot; &quot;(some-fn number? (1 2 3))&quot; &quot;(some number? (1 2 3))&quot; &quot;(number? 2)&quot; &quot;(some number? [ 1 2 3])&quot; &quot;(some number? '(1 2 3))&quot; &quot;(:simplescores cc)&quot; &quot;(doc map)&quot; &quot;(deref ccc)&quot; &quot;(doc deref)&quot; &quot;(doc def)&quot; &quot;(myvars)&quot; &quot;ccc&quot; &quot;(take 10 (nth (:wordlists ccc)3))&quot; &quot;(take 10 (nth (:wordlists ccc)4))&quot; &quot;(take 10 (nth (:wordlists ccc)5))&quot; &quot;(take 10 (nth (:wordlists ccc)7))&quot; &quot;(take 10 (nth (:wordlists ccc)8))&quot; &quot;(:decodedclues ccc)&quot; &quot;(def ccc (set-inital-partial-sol 4))&quot; &quot;(def ccc (set-inital-partial-sol 5))&quot; &quot;(:wordcountscores ccc)&quot; &quot;(:simplescores ccc)&quot; &quot;(keys ccc)&quot; &quot;(non-completed-clue? ccc)&quot; &quot;(make-child ccc (nth (:decodedclues ccc) 0) (nth (:wordlists ccc) 0))&quot; &quot;(make-child ccc (nth (:decodedclues ccc) 0) (nth (nth (:wordlists ccc) 0)0))&quot; &quot;(make-child ccc (nth (:decodedclues ccc) 3) (nth (nth (:wordlists ccc) 3)0))&quot; &quot;(make-child ccc (nth (:clues ccc) 3) (nth (nth (:wordlists ccc) 3)0))&quot; &quot;(filtercode {7 a, 13 w, 9 c, 5 s, 14 i, 10 u, 8 b} \&quot;abacus\&quot; [7 8 7 9 10 5] [7 8 7] [\&quot;aba\&quot; \&quot;aca\&quot;])&quot; &quot;{8 \\a}&quot; &quot;(println (:encodemap ccc))&quot; &quot;(filtercode {7 \\a, 13 \\w, 9 \\c, 5 \\s, 14 \\i, 10 \\u, 8 \\b} \&quot;abacus\&quot; [7 8 7 9 10 5] [7 8 7] [\&quot;aba\&quot; \&quot;aca\&quot;])&quot; &quot;(filtercode {13 \\w, 14 \\i} \&quot;abacus\&quot; [7 8 7 9 10 5] [7 8 7] [\&quot;aba\&quot; \&quot;aca\&quot;])&quot; &quot;(filtercode {13 \\w, 14 \\i} [7 8 7 9 10 5] \&quot;abacus\&quot; [7 8 7] [\&quot;aba\&quot; \&quot;aca\&quot;])&quot; &quot;(keys cccnew)&quot; &quot;(def cccnew (make-child ccc (nth (:clues ccc) 0) (nth (nth (:wordlists ccc) 0)0)))&quot; &quot;(:encodemap cccnew)&quot; &quot;(:simplescores cccnew)&quot; &quot;(:wordcountscores cccnew)&quot; &quot;(def childclue (children-from-clue ccc 0))&quot; &quot;(count child)&quot; &quot;(def childclue (children-from-clue ccc 1))&quot; &quot;(def childclue (children-from-clue ccc 2))&quot; &quot;(count childclue)&quot; &quot;childclue&quot; &quot;(:encodemap ccc)&quot; &quot;(def childclue (children-from-clue ccc 3))&quot; &quot;(:clue ccc)&quot; &quot;(:clue cc)&quot; &quot;(:clues cc)&quot; &quot;(defn children-from-clue\n  [cc clue-index]\n  (reduce #(conj %1 (make-child cc (nth (:clues cc) clue-index) %2)) (lazy-seq) (nth(:wordlists cc) clue-index)))&quot; &quot;(cc :clues)&quot; &quot;(cc :simplescores)&quot; &quot;(cc :wordcountscores)&quot; &quot;(cc1 :wordcountscores)&quot; &quot;((nth cc1 0) :wordcountscores)&quot; &quot;((nth cc1 1) :wordcountscores)&quot; &quot;((nth cc2 1) :simplescores)&quot; &quot;((nth cc2 2) :simplescores)&quot; &quot;((nth cc2 1) :wordcountscores)&quot; &quot;((nth cc2 2) :wordcountscores)&quot; &quot;(def cc2 (children-from-clue (nth cc1 0) 12))&quot; &quot;((nth cc2 0) :wordcountscores)&quot; &quot;((nth ))&quot; &quot;((nth cc2 0) :simplescores)&quot; &quot;((nth cc2 0) :decodedclues)&quot; &quot;(nice-print cc2 0)&quot; &quot;(nice-print cc2 1)&quot; &quot;(nice-print cc2 2)&quot; &quot;(type cc2)&quot; &quot;(type cc1)&quot; &quot;(make-child ccc (nth (:clues ccc) 0) (nth (nth (:wordlists ccc) 0)0))&quot; &quot;(make-child cc (nth (:clues cc) 0) (nth (nth (:wordlists cc) 0)0))&quot; &quot;(conj 1 (lazy-seq 3 4 5))&quot; &quot;(lazy-seq 3 4 5)&quot; &quot;(lazy-seq [3 4 5])&quot; &quot;(conj 1 (lazy-seq [3 4 5]))&quot; &quot;(conj  (lazy-seq [3 4 5])\n       1)&quot; &quot;(cons 1  (lazy-seq [3 4 5]))&quot; &quot;(cons 1 (range))&quot; &quot;(cons 1 (range 10))&quot; &quot;(type *1)&quot; &quot;(type (range 10))&quot; &quot;(type (range))&quot; &quot;cc1&quot; &quot;(count cc1)&quot; &quot;(nth cc1 0)&quot; &quot;(nth cc1 1)&quot; &quot;(nth cc1 2)&quot; &quot;(doc cons)&quot; &quot;(doc conj)&quot; &quot;(def cc1 (children-from-clue cc 1))&quot; &quot;(nice-print cc1 0)&quot; &quot;(def cc (get-cc 3))&quot; &quot;cc&quot; &quot;(def cc (set-inital-partial-sol (get-cc 3)))&quot;], :remote []}}</component>
</project>